#include "Process_data.h"

Process_data::Process_data(Win32_process_data win32_data) {
    this->data        = win32_data;
    this->start       = std::chrono::steady_clock::now();
    this->sessions    = std::vector<Process_data::Session>();

    this->is_tracked = false;
    this->is_active   = false;
    this->was_updated = false;
}

// Updating a process as if its new state is active
void Process_data::update_active() {
    if (this->is_active == false) {
        this->is_active = true;
        this->start     = std::chrono::steady_clock::now();
    } 
    else {
        // Nothing here
    }

    this->was_updated = true;
}

// Updating a process as if its new state is inactive
void Process_data::update_inactive() {
    if (this->is_active == true) {
        this->is_active = false;
        
        if (this->is_tracked) {
            Process_data::Session session(this->start, std::chrono::steady_clock::now());
            this->sessions.push_back(session);
        }
    }
    else {
        // Nothing here
    }

    this->was_updated = true;
}


bool Process_data::operator==(const Process_data& other) {
    return (
           this->data.exe_path      == other.data.exe_path 
        && this->data.creation_time == other.data.creation_time
    );
}

bool Process_data::operator==(const Win32_process_data& win32_data) {
    return (
           this->data.exe_path      == win32_data.exe_path 
        && this->data.creation_time == win32_data.creation_time
    );
}


// == Process_data::Session =================================================================

Process_data::Session::Session(std::chrono::steady_clock::time_point start,  std::chrono::steady_clock::time_point end) {
    this->start_time = start;
    this->end_time   = end;
}

Process_data::Session::~Session() {}

// == Just some functions ===================================================================


// NOTE(damian): these were generated by claude. ))
void convert_to_json(json* j, const Process_data* process_data) {
    *j = json{
        {"start", std::chrono::duration_cast<std::chrono::nanoseconds>(process_data->start.time_since_epoch()).count()},
        {"is_active", process_data->is_active},
        {"is_tracked", process_data->is_tracked},
        {"was_updated", process_data->was_updated},
        {"sessions", json::array()}
    };

    // Serialize sessions
    for (const auto& session : process_data->sessions) {
        j->at("sessions").push_back({
            {"start_time", std::chrono::duration_cast<std::chrono::nanoseconds>(session.start_time.time_since_epoch()).count()},
            {"end_time", std::chrono::duration_cast<std::chrono::nanoseconds>(session.end_time.time_since_epoch()).count()}
            });
    }

    // Serialize Win32_process_data
    (*j)["data"] = {
        {"pid", process_data->data.pid},
        {"started_threads", process_data->data.started_threads},
        {"ppid", process_data->data.ppid},
        {"base_priority", process_data->data.base_priority},
        {"exe_name", process_data->data.exe_name},
        {"exe_path", process_data->data.exe_path},
        {"priority_class", process_data->data.priority_class},
    };
}

int convert_from_json(const json* j, Process_data* process_data) {
    try {
        process_data->start = std::chrono::steady_clock::time_point(std::chrono::nanoseconds(j->at("start").get<uint64_t>()));
        process_data->is_active = j->at("is_active").get<bool>();
        process_data->is_tracked = j->at("is_tracked").get<bool>();
        process_data->was_updated = j->at("was_updated").get<bool>();

        // Sessions
        process_data->sessions.clear();
        for (const auto& s : j->at("sessions")) {
            auto start_ns = s.at("start_time").get<uint64_t>();
            auto end_ns = s.at("end_time").get<uint64_t>();
            process_data->sessions.emplace_back(
                std::chrono::steady_clock::time_point(std::chrono::nanoseconds(start_ns)),
                std::chrono::steady_clock::time_point(std::chrono::nanoseconds(end_ns))
            );
        }

        // Win32_process_data
        const json& d = j->at("data");
        process_data->data.pid = d.at("pid").get<DWORD>();
        process_data->data.started_threads = d.at("started_threads").get<DWORD>();
        process_data->data.ppid = d.at("ppid").get<DWORD>();
        process_data->data.base_priority = d.at("base_priority").get<LONG>();
        process_data->data.exe_name = d.at("exe_name").get<string>();
        process_data->data.exe_path = d.at("exe_path").get<string>();
        process_data->data.priority_class = d.at("priority_class").get<DWORD>();

        return 0; // Success
    }
    catch (const std::exception& e) {
        return -1; // Parsing error
    }
}