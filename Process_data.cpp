#include "Process_data.h"

Process_data::Process_data(Win32_process_data win32_data) {
    this->data        = win32_data;
    this->sessions    = std::vector<Process_data::Session>();

    this->steady_start = std::chrono::steady_clock::now();
    this->system_start = std::chrono::system_clock::now();

    this->is_tracked = false;
    this->is_active   = false;
    this->was_updated = false;
}

// Updating a process as if its new state is active
void Process_data::update_active() {
    if (this->is_active == false) {
        this->is_active    = true;
        this->steady_start = std::chrono::steady_clock::now();
        this->system_start = std::chrono::system_clock::now();
    } 
    else {
        // Nothing here
    }

    this->was_updated = true;
}

// Updating a process as if its new state is inactive
void Process_data::update_inactive() {
    if (this->is_active == true) {
        this->is_active = false;
        
        if (this->is_tracked) {
            Process_data::Session session(this->system_start, system_clock::now(), 
                                          this->steady_start,steady_clock::now());

            this->sessions.push_back(session);
        }
    }
    else {
        // Nothing here
    }

    this->was_updated = true;
}

bool Process_data::operator==(const Win32_process_data& win32_data) {
    if (this->is_tracked) {
        return this->data.exe_path == win32_data.exe_path;
    }
    else {
        return (
               this->data.exe_path == win32_data.exe_path
            && this->data.creation_time == win32_data.creation_time
        );
    }
}

bool Process_data::operator==(const Process_data& other) {
    if (other.data.exe_name == "Telegram.exe") {
        int x = 2;
    }

    if (this->is_tracked) {
        return this->data.exe_path == other.data.exe_path;
    }
    else {
        return (
               this->data.exe_path      == other.data.exe_path 
            && this->data.creation_time == other.data.creation_time
        );
    }
}

//bool Process_data::operator==(const Win32_process_data& win32_data) {
//    return (
//           this->data.exe_path      == win32_data.exe_path 
//        && this->data.creation_time == win32_data.creation_time
//    );
//}


// == Process_data::Session =================================================================

Process_data::Session::Session(system_clock::time_point system_start, system_clock::time_point system_end,
                               steady_clock::time_point steady_start, steady_clock::time_point steady_end
) {
    this->system_start_time = system_start;
    this->system_end_time   = system_end;

    this->steady_start_time = steady_start;
    this->steady_end_time   = steady_end;
}

// == Just some functions ===================================================================


// NOTE(damian): these were generated by claude. ))
void convert_to_json(json* j, const Process_data* process_data) {
    *j = json{
        {"steady_start", std::chrono::duration_cast<std::chrono::nanoseconds>(process_data->steady_start.time_since_epoch()).count()},
        {"system_start", std::chrono::duration_cast<std::chrono::nanoseconds>(process_data->system_start.time_since_epoch()).count()},
        {"is_active", process_data->is_active},
        {"is_tracked", process_data->is_tracked},
        {"was_updated", process_data->was_updated},
        {"sessions", json::array()}
    };

    // Serialize sessions
    for (const auto& session : process_data->sessions) {
        j->at("sessions").push_back({
            {"steady_start_time", std::chrono::duration_cast<std::chrono::nanoseconds>(session.steady_start_time.time_since_epoch()).count()},
            {"steady_end_time", std::chrono::duration_cast<std::chrono::nanoseconds>(session.steady_end_time.time_since_epoch()).count()},
            {"system_start_time", std::chrono::duration_cast<std::chrono::nanoseconds>(session.system_start_time.time_since_epoch()).count()},
            {"system_end_time", std::chrono::duration_cast<std::chrono::nanoseconds>(session.system_end_time.time_since_epoch()).count()}
            });
    }

    // Serialize Win32_process_data
    (*j)["data"] = {
        {"pid", process_data->data.pid},
        {"started_threads", process_data->data.started_threads},
        {"ppid", process_data->data.ppid},
        {"base_priority", process_data->data.base_priority},
        {"exe_name", process_data->data.exe_name},
        {"exe_path", process_data->data.exe_path},
        {"priority_class", process_data->data.priority_class},
        {"creation_time", process_data->data.creation_time},
        {"exit_time", process_data->data.exit_time},
        {"kernel_time", process_data->data.kernel_time},
        {"user_time", process_data->data.user_time},
        {"process_affinity", process_data->data.process_affinity},
        {"system_affinity", process_data->data.system_affinity},
        {"ram_usage", process_data->data.ram_usage},
        {"is_visible_app", process_data->data.is_visible_app}
    };
}

int convert_from_json(const json* j, Process_data* process_data) {
    try {
        // Deserialize time points
        process_data->steady_start = steady_clock::time_point(std::chrono::nanoseconds(j->at("steady_start").get<uint64_t>()));
        process_data->system_start = system_clock::time_point(std::chrono::duration_cast<system_clock::duration>(std::chrono::nanoseconds(j->at("system_start").get<uint64_t>())));

        // Deserialize flags
        process_data->is_active = j->at("is_active").get<bool>();
        process_data->is_tracked = j->at("is_tracked").get<bool>();
        process_data->was_updated = j->at("was_updated").get<bool>();

        // Deserialize sessions
        process_data->sessions.clear();
        for (const auto& s : j->at("sessions")) {
            auto steady_start_ns = s.at("steady_start_time").get<uint64_t>();
            auto steady_end_ns = s.at("steady_end_time").get<uint64_t>();
            auto system_start_ns = s.at("system_start_time").get<uint64_t>();
            auto system_end_ns = s.at("system_end_time").get<uint64_t>();

            process_data->sessions.emplace_back(
                system_clock::time_point(std::chrono::duration_cast<system_clock::duration>(std::chrono::nanoseconds(system_start_ns))),
                system_clock::time_point(std::chrono::duration_cast<system_clock::duration>(std::chrono::nanoseconds(system_end_ns))),
                steady_clock::time_point(std::chrono::nanoseconds(steady_start_ns)),
                steady_clock::time_point(std::chrono::nanoseconds(steady_end_ns))
            );
        }

        // Deserialize Win32_process_data
        const json& d = j->at("data");
        process_data->data.pid = d.at("pid").get<DWORD>();
        process_data->data.started_threads = d.at("started_threads").get<DWORD>();
        process_data->data.ppid = d.at("ppid").get<DWORD>();
        process_data->data.base_priority = d.at("base_priority").get<LONG>();
        process_data->data.exe_name = d.at("exe_name").get<string>();
        process_data->data.exe_path = d.at("exe_path").get<string>();
        process_data->data.priority_class = d.at("priority_class").get<DWORD>();
        process_data->data.creation_time = d.at("creation_time").get<ULONGLONG>();
        process_data->data.exit_time = d.at("exit_time").get<ULONGLONG>();
        process_data->data.kernel_time = d.at("kernel_time").get<ULONGLONG>();
        process_data->data.user_time = d.at("user_time").get<ULONGLONG>();
        process_data->data.process_affinity = d.at("process_affinity").get<SIZE_T>();
        process_data->data.system_affinity = d.at("system_affinity").get<SIZE_T>();
        process_data->data.ram_usage = d.at("ram_usage").get<SIZE_T>();
        process_data->data.is_visible_app = d.at("is_visible_app").get<bool>();

        return 0; // Success
    }
    catch (const std::exception& e) {
        return -1; // Parsing error
    }
}